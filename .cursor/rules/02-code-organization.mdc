---
description: File structure, naming conventions, and code organization patterns
alwaysApply: true
---

# Code Organization

## Directory Structure
```
src/
├── commands/           # Command implementations
│   ├── BaseCommand.ts  # Base class all commands extend
│   ├── index.ts        # Export all commands
│   └── *.ts           # Individual command files
├── formatters/         # Output formatting
│   ├── <entity>/      # Per-entity formatters
│   │   ├── Formatter.ts           # Interface definition
│   │   ├── PlainTextFormatter.ts  # Human-readable output
│   │   ├── JsonFormatter.ts       # JSON output
│   │   └── AlfredFormatter.ts     # Alfred workflow output
│   └── FormatterFactory.ts        # Factory for formatter creation
├── graphql/           
│   ├── queries.ts      # All GraphQL query definitions
│   └── generated/      # Codegen output (don't edit)
├── services/          
│   ├── BuildkiteClient.ts      # GraphQL API client
│   ├── BuildkiteRestClient.ts  # REST API client
│   ├── CacheManager.ts         # Cache handling
│   ├── CredentialManager.ts    # Token management
│   └── logger.ts               # Logging configuration
├── types/             
│   └── index.ts        # TypeScript type definitions
└── utils/             
    ├── parseBuildRef.ts         # Parse build references
    ├── textFormatter.ts         # Text formatting utilities
    └── errorUtils.ts           # Error handling utilities
```

## Command Implementation Pattern
```typescript
// src/commands/MyCommand.ts
import { BaseCommand, BaseCommandOptions } from './BaseCommand.js';

export interface MyCommandOptions extends BaseCommandOptions {
  // Add command-specific options
}

export class MyCommand extends BaseCommand {
  static requiresToken = true; // or false if no auth needed

  async execute(options: MyCommandOptions): Promise<number> {
    try {
      // Ensure initialization
      await this.ensureInitialized();
      
      // Command logic here
      
      return 0; // Success
    } catch (error) {
      this.handleError(error, options.debug);
      return 1; // Error
    }
  }
}
```

## Formatter Implementation Pattern
```typescript
// src/formatters/myentity/PlainTextFormatter.ts
import { BaseFormatter } from '../BaseFormatter.js';
import { MyEntity } from '../../types/index.js';

export class PlainTextFormatter extends BaseFormatter {
  formatEntities(entities: MyEntity[]): string {
    if (entities.length === 0) {
      return 'No entities found';
    }
    // Format logic
    return formatted;
  }
  
  formatError(action: string, error: any): string {
    return `Error ${action}: ${error.message}`;
  }
}
```

## Adding New GraphQL Queries
```typescript
// src/graphql/queries.ts
export const GET_MY_DATA = gql`
  query GetMyData($param: String!) {
    myData(param: $param) {
      id
      name
      # Always prefer html over text fields
      bodyHtml
    }
  }
`;
```

## Utility Functions Pattern
```typescript
// src/utils/myParser.ts
export function parseMyInput(input: string): ParsedResult {
  // Validation and parsing logic
  // Throw clear errors for invalid input
  return parsed;
}
```

## Import Conventions

### ES Module Requirements
**CRITICAL**: This project uses ES modules (`"type": "module"` in package.json)
- **ALWAYS use** ES module syntax (`import`/`export`)
- **NEVER use** CommonJS syntax (`require`/`module.exports`)
- This applies to ALL JavaScript and TypeScript files:
  - Source files (`.ts`, `.js`)
  - Test scripts (`.js`)
  - Build scripts
  - Any temporary test files

### Import Rules
- Use `.js` extension in imports (even for .ts files)
- Use relative imports within the same module
- Group imports: external → services → types → utils → local

```typescript
// External dependencies
import { Command } from 'commander';

// Services
import { BuildkiteClient } from '../services/BuildkiteClient.js';
import { logger } from '../services/logger.js';

// Types
import { Build, Pipeline } from '../types/index.js';

// Utils
import { parseBuildRef } from '../utils/parseBuildRef.js';

// Local
import { BaseCommand } from './BaseCommand.js';
```

### Common ES Module Patterns

#### ✅ CORRECT - ES Module Syntax
```javascript
// Imports
import { parseBuildRef } from './dist/utils/parseBuildRef.js';
import chalk from 'chalk';
import { BuildkiteClient } from './dist/services/BuildkiteClient.js';

// Exports
export default myFunction;
export { myFunction, myVariable };
```

#### ❌ WRONG - CommonJS Syntax (Will Cause Errors)
```javascript
// These will fail with "require is not defined in ES module scope"
const { parseBuildRef } = require('./dist/utils/parseBuildRef.js');
const chalk = require('chalk');

module.exports = myFunction;
module.exports = { myFunction, myVariable };
```

### Creating Test Scripts
When creating JavaScript test files, always use ES module syntax:

```javascript
#!/usr/bin/env node

// Use ES module imports
import { someFunction } from './dist/path/to/module.js';

// Test code
async function test() {
  const result = await someFunction('test');
  console.log(result);
}

// For async functions, handle properly
test().catch(console.error);
```

Run test scripts with: `node test-script.js`

## Naming Conventions
- **Files**: PascalCase for classes, camelCase for utilities
- **Commands**: PascalCase (e.g., `ListBuilds`, `ManageToken`)
- **Variables**: camelCase
- **Constants**: UPPER_SNAKE_CASE
- **Interfaces**: PascalCase with 'I' prefix optional
- **Types**: PascalCase

## UI Formatting Patterns

### Tip Formatting Guidelines
When displaying hints, tips, or suggestions to users, use the standardized `formatTips` utility:

#### Correct Usage Pattern
```typescript
import { formatTips, TipStyle } from '../../ui/theme.js';

// ✅ CORRECT - Use formatTips utility
const tips = [
  'Use --org <name> to filter to a specific organization',
  'Use --filter <text> to search by name',
  'Use --count 20 to see more'
];

if (tips.length > 0) {
  lines.push('');
  lines.push(formatTips(tips, TipStyle.GROUPED));
}

// ❌ AVOID - Manual formatting
lines.push(SEMANTIC_COLORS.dim(`→ Use --org <name> to filter`));
lines.push('Tips:');
lines.push('  → Use --filter <text> to search');
```

#### What formatTips Does
- Adds "Tips:" header automatically
- Prefixes each tip with arrow icon (→)
- Includes "Use --no-tips to hide these hints" automatically
- Applies consistent `SEMANTIC_COLORS.dim()` styling
- Returns formatted string ready to display

#### Contextual Tips
- Display tips AFTER showing data, not before
- Only show relevant tips based on the current context
- Collect all tips first, then call formatTips once

#### Examples in Formatters
```typescript
// In builds formatter
if (options?.organizationsCount > 1 && !options.orgSpecified) {
  const tips = ['Use --org <name> to filter to a specific organization'];
  lines.push('');
  lines.push(formatTips(tips, TipStyle.GROUPED));
}

// In build detail formatter
const hints = [];
if (!options?.failed && failedJobs.length > 0) {
  hints.push('Use --failed to show failure details');
}
if (!options?.annotations && hasAnnotations) {
  hints.push('Use --annotations to view annotation details');
}
if (hints.length > 0) {
  lines.push('');
  lines.push(formatTips(hints, TipStyle.GROUPED));
}

// In pipelines formatter
const hints = [];
if (pipelines.length > 20) {
  hints.push('Use --filter <text> to search by name or description');
}
if (hints.length > 0) {
  output.push('');
  output.push(formatTips(hints, TipStyle.GROUPED));
}
```

## Export Patterns
```typescript
// Always maintain src/commands/index.ts exports
export { BaseCommand } from './BaseCommand.js';
export { ListBuilds } from './ListBuilds.js';
// ... all other commands

// Always maintain src/formatters/index.ts exports  
export { FormatterFactory, FormatterType } from './FormatterFactory.js';
// ... formatter types

// Always maintain src/types/index.ts for shared types
export interface Build { /* ... */ }
export interface Pipeline { /* ... */ }
```